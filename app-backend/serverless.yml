service:
  name: precisely-backend

frameworkVersion: ">=1.21.0 <2.0.0"

provider:
  name: aws
  runtime: nodejs8.10
  stage: ${self:custom.common.stage}
  region: ${self:custom.common.region}
  profile: ${self:custom.common.profile}
  deploymentBucket: ${self:custom.common.account}-precisely-deployment-bucket

  ##
  ## Environment for handlers
  environment:
    STAGE: ${self:provider.stage}
    REGION: ${self:provider.region}
    ACCOUNT_ID: ${self:custom.common.accountId}

    LOG_LEVEL: ${self:custom.vars.logLevel}
    # NODE_ENV should only be "production" OR "development"
    # See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
    #      https://webpack.js.org/guides/production/#specify-the-environment
    # We set NODE_ENV automatically based on STAGE:
    #   production for beta and prod
    #   development for all other stages
    # Override by passing it as env var:
    #   NODE_ENV={production|development} yarn sls ...
    NODE_ENV: ${env:NODE_ENV, self:custom.vars.nodeEnv}

    # S3 buckets
    S3_BUCKET_GENETICS_VCF: ${self:custom.vars.geneticsVCFBucket}
    S3_BUCKET_USER_UPLOAD: ${self:custom.vars.userUploadBucket}
    S3_BUCKET_INGESTION_ERROR: ${self:custom.vars.ingestionErrorBucket}

    BASE_DOMAIN: ${self:custom.common.baseDomain} # the root domain, adjusted for developer environments
    GRAPHQL_API_PATH: ${self:custom.common.graphQLAPIPath}

    # Auth0 values - needed for verifying Auth0 tokens
    AUTH0_TENANT_NAME: ${self:custom.common.auth0Tenant} # set in Auth0: dev-precisely, beta-precisely, prod-precisely
    AUTH0_API_IDENTIFIER: https://${self:custom.common.account}-precise.ly/graphql/api

    # Quick and dirty way to define admins for now
    # TODO: better approach
    ADMIN_EMAILS: "aneil@precise.ly,vetoshev@gmail.com"

    DYNAMODB_LOCAL_ENDPOINT: http://localhost:${self:custom.dynamodb.start.port}

resources:
  - Resources: ${file(./serverless/resources/roles.yml)}
  - Resources: ${file(./serverless/resources/cors.yml)}
  - Resources: ${file(./serverless/resources/dynogels-tables.js):Definitions}
  - Resources: ${file(./serverless/resources/s3-buckets.yml)}
  - Resources: ${file(./serverless/resources/logs.yml)}
  - Resources: ${file(./serverless/resources/ecs-fargate.yml)}
  - Resources: ${file(./serverless/resources/network/subnet.yml)}
  - Resources: ${file(./serverless/resources/network/routes.yml)}
  - Resources: ${file(./serverless/resources/network/gateway.yml)}

plugins:
  # You'll need to comment out the severless-domain-manager plugin on the first deploy:
  # 1. yarn sls create_domain
  # 2. comment out the serverless-domain-manager plugin
  # 3. yarn deploy
  # 4. uncomment the plugin
  # 5. yarn deploy
  # This is likely related to this issue: https://github.com/serverless/serverless/issues/4029#issuecomment-319984929
  - serverless-domain-manager
  - serverless-webpack
  - serverless-api-stage
  - "@aneilbaboo/serverless-dynamodb-local" # this version installs dynamodb to project root by default
  - serverless-pseudo-parameters
  - serverless-plugin-scripts
  - serverless-offline # serverless-offline must be last in the list

custom:
  common: ${file(../serverless/common.js):vars}

  vars:
    authorizerTTL: ${env:AUTHORIZER_TTL,self:custom.vars.authorizerTTLMap.${self:custom.common.account},self:custom.vars.authorizerTTLMap.default}
    authorizerTTLMap:
      dev: 0
      default: 300

    nodeEnv: ${env:NODE_ENV, self:custom.vars.nodeEnvMap.${self:custom.common.account}}
    nodeEnvMap:
      dev: development
      prod: production
      beta: production

    logLevel: "DEBUG" #${env:LOG_LEVEL, ${self:custom.vars.logLevelMap.${self:custom.common.account}}}
    logLevelMap:
      prod: INFO
      beta: INFO
      dev: DEBUG
      offline: DEBUG

    # S3 resource names
    geneticsVCFBucket: ${self:provider.stage}-precisely-genetics-vcf
    userUploadBucket: ${self:provider.stage}-precisely-user-upload
    ingestionErrorBucket: ${self:provider.stage}-precisely-ingestion-error

    # Ingestion ECS Fargate Task
    ingestionECSTaskDefinitionName: ${self:provider.stage}-IngestionECSTaskDefinition
    ingestionContainerName: ${self:provider.stage}-IngestionContainerName
    ingestionClusterName: ${self:provider.stage}-IngestionECSClusterName

  customDomain: # domain-manager settings - for the api
    #domainName: ${self:custom.common.apiDomain}
    basePath: ''
    stage: ${self:provider.stage}
    createRoute53Record: true
    certificateName: ${self:custom.common.certificateName}
    endpointType: regional

  dynamodb: # dynamodb-local settings
    start:
      port: ${env:DYNAMODB_LOCAL_PORT, "8000"}
      inMemory: true
      migrate: true
      # seed: true

  scripts:
    commands:
      console: ts-node -r tsconfig-paths/register
      test: jest
      "test:watch": jest --watch
      env: env

  serverless-offline:
    port: ${self:custom.common.offlineAPIPort}

  stageSettings: # serverless-api-stage plugin
    ${self:custom.stageSettingsMap.${self:custom.common.account}, self:custom.stageSettingsMap.default}

  stageSettingsMap:
    dev:
      MethodSettings:
        LoggingLevel: INFO # INFO ERR or NONE
        CachingEnabled: false
    default:
      CacheClusterEnabled: true
      CacheClusterSize: '0.5'
      MethodSettings:
        LoggingLevel: INFO # INFO ERR or NONE
        CachingEnabled: true
        CacheTtlInSeconds: 3600

  webpackIncludeModules: true

functions:
  APIAuthorizer:
    role: PreciselyDefaultRole
    handler: src/services/auth/handlers.apiAuthorizer
    cors: true

  GraphQLPlayground:
    role: PreciselyDefaultRole
    handler: src/services/graphql/handlers.playgroundHandler
    events:
      - http:
          path: ${self:custom.common.graphQLAPIPath}
          method: get
          cors: true

  GraphQLAPI:
    role: PreciselyGraphQLAPIRole
    handler: src/services/graphql/handlers.apiHandler
    events:
      - http:
          path: ${self:custom.common.graphQLAPIPath}
          method: post
          cors: true
          authorizer:
            name: APIAuthorizer
            type: request
            resultTtlInSeconds: ${self:custom.vars.authorizerTTL}

  # VCF ingester is triggered by new file in S3_BUCKET_GENETICS_VCF
  VCFIngester:
    handler: src/services/genetics-pipeline/handlers.vcfIngester
    events:
      - s3:
          bucket: GeneticsVCF
          event: s3:ObjectCreated:*

  # Raw data uploader is triggered by new file in any of the raw data buckets
  RawDataUpload:
    handler: src/services/genetics-pipeline/handlers.rawDataUpload
    environment:
      INGESTION_CLUSTER: ${self:custom.vars.ingestionClusterName}
      INGESTION_TASK_NAME: ${self:custom.vars.ingestionECSTaskDefinitionName}
      INGESTION_CONTAINER_NAME: ${self:custom.vars.ingestionContainerName}
      SUBNET_ONE:
        Ref: DefaultSubnetOne
      SUBNET_TWO:
        Ref: DefaultSubnetTwo

    role:
      Fn::GetAtt: ["RawUploadLambdaRole", "Arn"]
    events:
      - s3:
          bucket: UserUpload
          event: s3:ObjectCreated:*
